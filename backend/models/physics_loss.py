"""\nPhysics-Informed Loss Module for PINN\nImplements Navier-Stokes equations as physics constraints\nContinuity: ∇·u = 0\nMomentum: Convective + Pressure + Viscous terms\n"""\n\nimport torch\nimport torch.nn as nn\nfrom typing import Tuple\n\n\nclass PhysicsLoss(nn.Module):\n    """\n    Calculates physics-informed loss based on Navier-Stokes equations.\n    """\n    \n    def __init__(self, rho: float = 1.225, nu: float = 1.81e-5):\n        super().__init__()\n        self.rho = rho\n        self.nu = nu\n    \n    def forward(\n        self,\n        model_output: Tuple[torch.Tensor, torch.Tensor, torch.Tensor],\n        x: torch.Tensor,\n        y: torch.Tensor,\n        reynolds: float,\n        mach: float\n    ) -> torch.Tensor:\n        u, v, p = model_output\n        \n        if not x.requires_grad:\n            x.requires_grad_(True)\n        if not y.requires_grad:\n            y.requires_grad_(True)\n        \n        # ========== CONTINUITY EQUATION ==========\n        du_dx = torch.autograd.grad(\n            outputs=u.sum(), inputs=x, create_graph=True, retain_graph=True,\n            allow_unused=True\n        )[0]\n        if du_dx is None:\n            du_dx = torch.zeros_like(u)\n        \n        dv_dy = torch.autograd.grad(\n            outputs=v.sum(), inputs=y, create_graph=True, retain_graph=True,\n            allow_unused=True\n        )[0]\n        if dv_dy is None:\n            dv_dy = torch.zeros_like(v)\n        \n        continuity = du_dx + dv_dy\n        continuity_loss = torch.mean(continuity ** 2)\n        \n        # ========== MOMENTUM X-EQUATION ==========\n        du_dx_full = torch.autograd.grad(\n            outputs=u.sum(), inputs=x, create_graph=True, retain_graph=True,\n            allow_unused=True\n        )[0]\n        if du_dx_full is None:\n            du_dx_full = torch.zeros_like(u)\n        \n        du_dy = torch.autograd.grad(\n            outputs=u.sum(), inputs=y, create_graph=True, retain_graph=True,\n            allow_unused=True\n        )[0]\n        if du_dy is None:\n            du_dy = torch.zeros_like(u)\n        \n        d2u_dx2 = torch.autograd.grad(\n            outputs=du_dx_full.sum(), inputs=x, create_graph=True, retain_graph=True,\n            allow_unused=True\n        )[0]\n        if d2u_dx2 is None:\n            d2u_dx2 = torch.zeros_like(u)\n        \n        d2u_dy2 = torch.autograd.grad(\n            outputs=du_dy.sum(), inputs=y, create_graph=True, retain_graph=True,\n            allow_unused=True\n        )[0]\n        if d2u_dy2 is None:\n            d2u_dy2 = torch.zeros_like(u)\n        \n        dp_dx = torch.autograd.grad(\n            outputs=p.sum(), inputs=x, create_graph=True, retain_graph=True,\n            allow_unused=True\n        )[0]\n        if dp_dx is None:\n            dp_dx = torch.zeros_like(p)\n        \n        convective_x = u * du_dx_full + v * du_dy\n        pressure_x = -1.0 / self.rho * dp_dx\n        viscous_x = self.nu * (d2u_dx2 + d2u_dy2) / max(reynolds / 1e6, 0.1)\n        \n        momentum_x = convective_x - pressure_x - viscous_x\n        momentum_x_loss = torch.mean(momentum_x ** 2)\n        \n        # ========== MOMENTUM Y-EQUATION ==========\n        dv_dx = torch.autograd.grad(\n            outputs=v.sum(), inputs=x, create_graph=True, retain_graph=True,\n            allow_unused=True\n        )[0]\n        if dv_dx is None:\n            dv_dx = torch.zeros_like(v)\n        \n        dv_dy_full = torch.autograd.grad(\n            outputs=v.sum(), inputs=y, create_graph=True, retain_graph=True,\n            allow_unused=True\n        )[0]\n        if dv_dy_full is None:\n            dv_dy_full = torch.zeros_like(v)\n        \n        d2v_dx2 = torch.autograd.grad(\n            outputs=dv_dx.sum(), inputs=x, create_graph=True, retain_graph=True,\n            allow_unused=True\n        )[0]\n        if d2v_dx2 is None:\n            d2v_dx2 = torch.zeros_like(v)\n        \n        d2v_dy2 = torch.autograd.grad(\n            outputs=dv_dy_full.sum(), inputs=y, create_graph=True, retain_graph=True,\n            allow_unused=True\n        )[0]\n        if d2v_dy2 is None:\n            d2v_dy2 = torch.zeros_like(v)\n        \n        dp_dy = torch.autograd.grad(\n            outputs=p.sum(), inputs=y, create_graph=True, retain_graph=True,\n            allow_unused=True\n        )[0]\n        if dp_dy is None:\n            dp_dy = torch.zeros_like(p)\n        \n        convective_y = u * dv_dx + v * dv_dy_full\n        pressure_y = -1.0 / self.rho * dp_dy\n        viscous_y = self.nu * (d2v_dx2 + d2v_dy2) / max(reynolds / 1e6, 0.1)\n        \n        momentum_y = convective_y - pressure_y - viscous_y\n        momentum_y_loss = torch.mean(momentum_y ** 2)\n        \n        # ========== TOTAL PHYSICS LOSS ==========\n        total_physics_loss = (\n            continuity_loss + \n            momentum_x_loss + \n            momentum_y_loss\n        )\n        \n        return total_physics_loss\n\n\ndef pinn_loss(\n    model_output: Tuple[torch.Tensor, torch.Tensor, torch.Tensor],\n    x: torch.Tensor,\n    y: torch.Tensor,\n    reynolds: float,\n    mach: float,\n    rho: float = 1.225,\n    nu: float = 1.81e-5\n) -> torch.Tensor:\n    """Functional wrapper for physics loss calculation."""\n    physics_loss_module = PhysicsLoss(rho=rho, nu=nu)\n    return physics_loss_module(model_output, x, y, reynolds, mach)
